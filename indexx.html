<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>KuCoin Real-time Dashboard (WebSocket)</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: Arial, sans-serif; background:#f5f7fa; color:#1f2937; margin:0; padding:16px; }
    .container { max-width:1200px; margin:0 auto; background:#fff; padding:14px; border-radius:8px; box-shadow:0 6px 18px rgba(15,23,42,0.06); }
    header { display:flex; align-items:center; justify-content:space-between; gap:12px; }
    h1 { font-size:18px; margin:0; }
    .controls { margin:12px 0; display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    input[type="number"] { width:100px; padding:6px; border-radius:6px; border:1px solid #e5e7eb; }
    table { width:100%; border-collapse:collapse; margin-top:8px; }
    thead th { text-align:left; padding:8px; border-bottom:1px solid #e6e6e6; font-size:13px; color:#374151; }
    tbody td { padding:8px; border-bottom:1px dashed #f1f5f9; vertical-align:middle; font-size:13px; }
    .small-canvas { width:120px; height:30px; display:block; }
    .status { font-size:13px; color:#6b7280; }
    .green { color:#059669; } .red { color:#ef4444; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>KuCoin Real-time Dashboard (WebSocket)</h1>
      <div class="status" id="status">Bağlantı: <strong id="connState">Hazır</strong></div>
    </header>

    <div class="controls">
      Yenileme (ms): <input id="interval" type="number" value="1000" min="200" step="100" />
      Gösterilecek coin sayısı: <input id="limit" type="number" value="200" min="10" max="1000" />
      <button id="restartBtn">WebSocket Yeniden Başlat</button>
      <div style="margin-left:auto; font-size:13px; color:#6b7280;">Not: Tarayıcı doğrudan KuCoin'e bağlanır. Public token 24 saat geçerli.</div>
    </div>

    <table id="ticker-table" aria-live="polite">
      <thead>
        <tr>
          <th>Symbol</th>
          <th>Last</th>
          <th>Change%</th>
          <th>BestBid / BestAsk</th>
          <th>Vol (last size)</th>
          <th>Spark</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

<script>
(async function(){

  // ---------- CONFIG ----------
  const BULLET_PUBLIC = "https://api.kucoin.com/api/v1/bullet-public"; // public spot token
  const TOPIC_ALL = "/market/ticker:all";
  const MAX_HISTORY = 40; // sparkline için kaç değer saklansın
  // ----------------------------

  const statusEl = document.getElementById("connState");
  const tableBody = document.querySelector("#ticker-table tbody");
  const intervalInput = document.getElementById("interval");
  const limitInput = document.getElementById("limit");
  const restartBtn = document.getElementById("restartBtn");

  let ws = null;
  let charts = {};
  let historyMap = {}; // { symbol: [prices...] }
  let rowsMap = {}; // { symbol: trElement }
  let recvBuffer = {}; // optional, we can buffer messages until render tick
  let renderTimer = null;
  let renderInterval = parseInt(intervalInput.value) || 1000;

  // helpers
  function setStatus(txt, cls) {
    statusEl.textContent = txt;
    statusEl.className = cls ? cls : "";
  }

  function formatNum(n, maxFrac=6) {
    if (n === null || n === undefined || isNaN(n)) return "-";
    // show up to 6 decimal places for small numbers, else integer-like
    if (Math.abs(n) >= 1) return Number(n).toLocaleString(undefined, {maximumFractionDigits: 2});
    return Number(n).toLocaleString(undefined, {maximumFractionDigits: maxFrac});
  }

  function createRowIfMissing(sym) {
    if (rowsMap[sym]) return rowsMap[sym];
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td class="sym">${sym}</td>
      <td class="last">-</td>
      <td class="chg">-</td>
      <td class="bbba">-</td>
      <td class="vol">-</td>
      <td class="spark"><canvas id="c_${sym.replace(/[^a-zA-Z0-9]/g,'_')}" class="small-canvas"></canvas></td>
    `;
    // append at end
    tableBody.appendChild(tr);
    rowsMap[sym] = tr;
    return tr;
  }

  // Chart.js small-line factory
  function createOrUpdateChart(sym, dataArr) {
    const canvasId = `c_${sym.replace(/[^a-zA-Z0-9]/g,'_')}`;
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;
    const ctx = canvas.getContext('2d');

    if (charts[canvasId]) {
      charts[canvasId].data.datasets[0].data = dataArr;
      charts[canvasId].update('none');
    } else {
      charts[canvasId] = new Chart(ctx, {
        type: 'line',
        data: {
          labels: dataArr.map((_,i)=>i),
          datasets: [{
            data: dataArr,
            borderWidth: 1,
            pointRadius: 0,
            tension: 0.35,
            borderColor: '#3b82f6' // Chart.js default color; you can change
          }]
        },
        options: {
          responsive: false,
          animation: false,
          maintainAspectRatio: false,
          scales: { x: { display: false }, y: { display: false } },
          plugins: { legend: { display: false }, tooltip: { enabled: false } }
        }
      });
    }
  }

  // Render loop (batched render)
  function startRenderLoop() {
    if (renderTimer) clearInterval(renderTimer);
    renderInterval = parseInt(intervalInput.value) || 1000;
    renderTimer = setInterval(() => {
      // render buffer
      const keys = Object.keys(recvBuffer);
      // sort by vol or unchanged? we will render all but limit displayed
      keys.sort((a,b) => {
        const av = parseFloat(recvBuffer[a]?.data?.size || 0);
        const bv = parseFloat(recvBuffer[b]?.data?.size || 0);
        return bv - av;
      });
      const limit = parseInt(limitInput.value) || 200;
      const sliced = keys.slice(0, limit);

      // clear table and reappend in sorted order for deterministic ordering
      tableBody.innerHTML = "";
      sliced.forEach(sym => {
        const pkt = recvBuffer[sym];
        const data = pkt.data;
        const price = parseFloat(data.price);
        const bestBid = parseFloat(data.bestBid);
        const bestAsk = parseFloat(data.bestAsk);
        const size = parseFloat(data.size);

        // history
        if (!historyMap[sym]) historyMap[sym] = [];
        const h = historyMap[sym];
        h.push(price);
        if (h.length > MAX_HISTORY) h.shift();

        const tr = createRowIfMissing(sym);
        tr.querySelector(".last").textContent = formatNum(price);
        const change = pkt._changePercent;
        const chgEl = tr.querySelector(".chg");
        if (change !== undefined) {
          chgEl.textContent = (change>=0?"+":"") + change.toFixed(2) + "%";
          chgEl.className = "chg " + (change>=0? "green":"red");
        } else {
          chgEl.textContent = "-";
        }
        tr.querySelector(".bbba").textContent = `${formatNum(bestBid)}/${formatNum(bestAsk)}`;
        tr.querySelector(".vol").textContent = formatNum(size, 6);

        // create canvas if needed then chart
        tableBody.appendChild(tr); // reappend in new order
        createOrUpdateChart(sym, h);
      });

    }, renderInterval);
  }

  // Build WS connect URL by fetching bullet-public
  async function getWsUrlAndToken() {
    try {
      // KuCoin expects POST to /api/v1/bullet-public for public token
      const resp = await fetch(BULLET_PUBLIC, { method: "POST" });
      const json = await resp.json();
      const data = json?.data;
      if (!data) throw new Error("No data in bullet-public response");
      // pick first server
      const server = (data.instanceServers && data.instanceServers[0]) || null;
      if (!server) throw new Error("No instanceServers returned");
      const endpoint = server.endpoint; // e.g. wss://ws-api-spot.kucoin.com/endpoint
      const token = data.token;
      // connectId random
      const connectId = "ck_" + Math.random().toString(36).slice(2,10);
      const wsUrl = endpoint + "?token=" + encodeURIComponent(token) + "&connectId=" + connectId;
      return { wsUrl, pingInterval: server?.pingInterval || 10000 };
    } catch (err) {
      console.error("bullet-public error:", err);
      throw err;
    }
  }

  // Start websocket and subscribe
  async function startWs() {
    setStatus("Token alınıyor...", "");
    try {
      const info = await getWsUrlAndToken();
      setStatus("WS bağlantısı kuruluyor...", "");
      ws = new WebSocket(info.wsUrl);

      ws.onopen = () => {
        setStatus("WS açık, abone olunuyor...", "");
        // subscribe to all tickers
        const subMsg = {
          id: Date.now(),
          type: "subscribe",
          topic: TOPIC_ALL,
          response: true
        };
        ws.send(JSON.stringify(subMsg));
        // send ping periodically if needed (KuCoin requires ping/pong)
        // also the server may send ping requests; handle in onmessage
        setStatus("Abone olundu. Veri akışı bekleniyor...", "green");
      };

      ws.onmessage = (evt) => {
        try {
          const msg = JSON.parse(evt.data);
          // message types: welcome, ping, message, etc.
          if (msg.type === "welcome") {
            // initial handshake
            // console.log("welcome");
            return;
          }
          if (msg.type === "ping") {
            // reply pong
            ws.send(JSON.stringify({ id: Date.now(), type: "pong" }));
            return;
          }
          if (msg.type === "message" && msg.topic && msg.data) {
            // msg.data may contain fields; for /market/ticker:all msg.data is an array? docs show object
            // For /market/ticker:all, KuCoin pushes ticker list; but often msg.data is single ticker object with symbol-based data
            // We'll handle both array and single object
            if (Array.isArray(msg.data)) {
              msg.data.forEach(d => handleTickerMessage(d));
            } else {
              handleTickerMessage(msg.data);
            }
          }
        } catch (e) {
          console.error("ws msg parse err", e, evt.data);
        }
      };

      ws.onclose = () => {
        setStatus("WS kapandı. Yeniden bağlanmak için 'Yeniden Başlat' butonunu kullan.", "red");
      };

      ws.onerror = (e) => {
        console.error("WS error", e);
        setStatus("WS hata: konsolu kontrol et.", "red");
      };

      // keepalive ping from client side each 10s (safe)
      let pingTimer = setInterval(() => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          try { ws.send(JSON.stringify({ id: Date.now(), type: "ping" })); } catch(e){}
        }
      }, 10000);

      // cleanup on manual restart
      restartBtn.onclick = () => {
        if (ws) {
          ws.close();
          ws = null;
        }
        clearInterval(pingTimer);
        setTimeout(()=> {
          historyMap = {}; rowsMap = {}; recvBuffer = {}; charts = {};
          tableBody.innerHTML = "";
          start();
        }, 350);
      };

    } catch (err) {
      setStatus("Token/WS hatası: " + (err.message || err), "red");
      console.error(err);
    }
  }

  // handle single ticker object; structure per docs: { sequence, price, size, bestAsk, bestAskSize, bestBid, bestBidSize, symbol, time }
  function handleTickerMessage(obj) {
    if (!obj) return;
    // if the msg is a snapshot containing 'ticker' field, handle
    const data = obj.ticker ? obj.ticker : obj;
    const symbol = data.symbol || data.sequence ? (data.symbol || data.symbol) : null;
    const sym = data.symbol || data.symbol || (data.s && data.s) || null;
    // KuCoin's ticker object uses 'symbol' like "BTC-USDT" or field name might be 'symbol' or 'symbol' present; fallback to data.productId?
    const symbolFinal = data.symbol || data.symbol || data.symbol || data.s || data.symbol || null;
    // In practice KuCoin uses "symbol" property like "BTC-USDT". We'll attempt to get it robustly:
    const finalSym = data.symbol || data.symbol || data.symbol || data.s || data.symbol || data.symbol || data.productId || data.symbol || null;
    // But usually data has 'symbol', use that:
    const S = data.symbol || data.symbol || data.symbol || data.s || data.productId || data.symbol;
    if (!S) return;
    const price = parseFloat(data.price || data.last || data.p) || 0;
    const bestBid = parseFloat(data.bestBid || data.bestBid) || 0;
    const bestAsk = parseFloat(data.bestAsk || data.bestAsk) || 0;
    const size = parseFloat(data.size || data.size) || 0;

    // compute short change% vs last history
    const hist = historyMap[S] || [];
    let changePercent = undefined;
    if (hist.length > 0) {
      try {
        const prev = hist[hist.length - 1];
        if (prev && prev > 0) changePercent = ((price - prev) / prev) * 100;
      } catch(e){}
    }

    // put into buffer keyed by symbol
    recvBuffer[S] = { data: { price, bestBid, bestAsk, size, symbol: S }, _lastPrice: price, _changePercent: changePercent || 0 };
  }

  // start process
  async function start() {
    // reset
    recvBuffer = {};
    historyMap = {};
    rowsMap = {};
    charts = {};
    tableBody.innerHTML = "";
    await startWs();
    startRenderLoop();
    setStatus("Çalışıyor", "green");
  }

  // start on load
  start();

  // allow UI controls to change render interval and limit
  intervalInput.addEventListener("change", () => {
    startRenderLoop();
  });
  limitInput.addEventListener("change", () => {
    // will take effect on next render tick
  });

  // helper: graceful unload
  window.addEventListener("beforeunload", () => {
    try { if (ws) ws.close(); } catch(e){}
  });

})();
</script>
</body>
</html>
